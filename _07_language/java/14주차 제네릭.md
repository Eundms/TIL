# 14주차: 제네릭

생성 일시: 2022년 11월 15일 오전 10:41
태그: whiteship

### **목표**

자바의 제네릭에 대해 학습하세요.

[https://docs.oracle.com/javase/tutorial/java/generics/index.html](https://docs.oracle.com/javase/tutorial/java/generics/index.html)

### **학습할 것 (필수)**

- ~~제네릭 사용법~~
- 제네릭 주요 개념 (~~바운디드 타입~~, ~~와일드 카드~~)
- 제네릭 메소드 만들기
- Erasure

---

### 제네릭

형식 매개 변수는 입력이 다른 동일한 코드를 재사용할 수 있는 방법을 제공

- 형식 매개변수에 대한 입력 : 값
- 유형 매개변수에 대한 입력 : 유형

### 장점

- 컴파일 타임에 더 강력한 유형 검사
- 캐스팅이 필요없음

```java
List list = new ArrayList();
list.add("hello");
String s = (String) list.get(0);

List<String> list = new ArrayList<String>();
list.add("hello");
String s = list.get(0);   // no cast
```

### Generic Types

```java
public class Box {
    private Object object;

    public void set(Object object) { this.object = object; }
    public Object get() { return object; }
}
```

### Generic Version of the Box Class

```java
/**
 * Generic version of the Box class.
 * @param <T> the type of the value being boxed
 */
public class Box<T> {
    // T stands for "Type"
    private T t;

    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
```

### ****Type Parameter Naming Conventions****

- E - Element (used extensively by the Java Collections Framework)
- K - Key
- N - Number
- T - Type
- V - Value
- S,U,V etc. - 2nd, 3rd, 4th types

### ****Invoking and Instantiating a Generic Type****

```java
Box<Integer> integerBox = new Box<>(); //Type Argument - Integer
```

### 여러개를 가질 수 있다.

```java
public interface Pair<K, V> {
    public K getKey();
    public V getValue();
}

public class OrderedPair<K, V> implements Pair<K, V> {
    private K key;
    private V value;

    public OrderedPair(K key, V value) {
			this.key = key;
			this.value = value;
    }

    public K getKey()	{ return key; }
    public V getValue() { return value; }
}
```

### Parameterized Types

```java
OrderedPair<String, Box<Integer>> p = new OrderedPair<>("primes", new Box<Integer>(...));
```

### Raw Types

```java
Box<String> stringBox = new Box<>();
Box rawBox = new Box(); // Box<T>의 원시 유형 생성
rawBox.set(8); // 확인되지 않은 set(T) 호출
```

```java
public class WarningDemo {
    public static void main(String[] args){
        Box<Integer> bi;
        bi = createBox();
    }

    static Box createBox(){
        return new Box();
    }
}
```

## 와일드 카드

- Unbounded wildcard
    
    `List<?>` 
    
- Lower Bounded Wildcard
    
    `List<? super Integer> list` : Integer
    
- Upper Bounded Wildcard
    
    `List<? extends Foo> list` : Foo 의 subtype에서 work할 수 있도록
    

![generics-listParent.gif](./_14/generics-listParent.gif)

![generics-wildcardSubtyping.gif](./_14/generics-wildcardSubtyping.gif)

### Wildcard Capture and Helper Methods

```java
import java.util.List;

public class WildcardError {

    void foo(List<?> i) {
        i.set(0, i.get(0));
    }
}
```

### Erasure

컴파일 타임에만 타입 제약 조건을 정의하고, 런타임에는 타입을 제거한다

- unbounded Type(<?>, <T>)는 Object로 변환합니다.
- bound type(<E extends Comparable>)의 경우는 Object가 아닌 Comprarable로 변환합니다.
- 제네릭 타입을 사용할 수 있는 일반 클래스, 인터페이스, 메소드에만 소거 규칙을 적용합니다.
- 타입 안정성 보존을 위해 필요하다면 type casting을 넣습니다.
- 확장된 제네릭 타입에서 다형성을 보존하기 위해 bridge method를 생성합니다.